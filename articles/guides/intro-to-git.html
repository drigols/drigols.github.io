<!DOCTYPE html>
<!-- Início do documento HTML5 -->
<html lang="en">
    <!-- Início do head -->
    <head>
        <!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

        <!-- Título da página -->
        <title>Introdução ao Git</title>

        <!-- Ícone da página -->
        <link href="../../images/icon.ico" rel="icon">

        <!-- Bootstrap CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" integrity="sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M"
            crossorigin="anonymous">

        <!-- My internal CSS -->
        <link rel="stylesheet" href="../../css/style.css">
        <link rel="stylesheet" href="../../vendors/freelancer/freelancer.min.css">
        <link rel="stylesheet" href="../../vendors/font-awesome/css/font-awesome.min.css">
    </head>
    <!-- /Fim do head -->

    <!-- Início do corpo(body) HTML5 -->
    <body>

        <!-- Início da section de artigos -->
        <div id="articles">

            <!-- Início do Navigation -->
                <nav class="navbar sticky-top fixed-top navbar-expand-lg navbar-light style="background-color: #e3f2fd;" bg-light">
                    <a class="navbar-brand" href="../../index.html">drigols</a>
                </nav>
            <!-- /Fim do Navigation -->

            <!-- Quebra de linha para não colar no Navigation -->
            <br><br>
            <!-- Início do container de artigos -->
            <div class="container box-articles">

                <!-- Início da linha(.row) header do artigo -->
                <div class="row">
                    <div class="col-md-12">
                        <img class="img-fluid mx-auto d-block" src="https://git-scm.com/images/logos/2color-lightbg@2x.png" alt="git-logo">                    
                    </div>
                </div>
                <!-- /Fim da linha(.row) header do artigo -->
                <br>

                <!-- Início da linha(.row) conteúdo do artigo  -->
                <div class="row">
                    <!-- início do col-md-12 -->
                    <div class="col-md-12">

                        <ul>
                            <li class="list-inline"><h6>01 - Primeiro passos</h3></li>
                            <li class="list-inline"><a href="#introduction">
								1.0 - Introdução</a>
								<ul>
									<li class="list-inline"><a href="#git-reset">1.0.0 - git reset</a></li>
								</ul>
							</li>
                            <li class="list-inline"><a href="#estados">1.1 - Estados</a></li>
                            <li class="list-inline"><a href="#setting">1.2 - Configuração inicial</a></li>
                        </ul>

                        <ul>
                            <li class="list-inline"><h6>02 - Git Essencial</h3></li>
                            <li class="list-inline"><a href="#commit-styleguide">2.0 - Commit StyleGuide</a></li>
                            <li class="list-inline"><a href="#git-log">2.1 - Git log</a></li>
                            <li class="list-inline"><a href="#trabalhando-com-remotos">
								2.2 - Trabalhando com remotos
								<ul>
									<li class="list-inline"><a href="#fetch">2.2.1 - Git fecth</a></li>
								</ul>
							</a></li>
						</ul>
						
                        <ul>
							<li class="list-inline"><h6>03 - Ramificação (Branching) no Git</h3></li>
							<li class="list-inline"><a href="#branch">3.0 - Branch</a></li>
							<li class="list-inline"><a href="#merging">3.1 - Merging </a></li>
							<li class="list-inline"><a href="#gerenciamento-de-branch">3.2 - Gerenciamento de Branch</a></li>
							<li class="list-inline"><a href="#workflows">
								3.3 - Fluxo de trabalho com branch</a>
								<ul>
									<li class="list-inline"><a href="#topic">3.3.0 - Branches Tópicos (topic)</a></li>
								</ul>
							</li>
							<li class="list-inline"><a href="#branch-remotas">3.4 - Branch remotas + git fetch</a></li>
							<li class="list-inline"><a href="#rebasing">3.5 - Rebasing</a></li>
						</ul>

						<ul>
							<li class="list-inline"><a href="#reference">Referências</a></li>
						</ul>

                        <br><br>
                        <!-- Início da seção 1.0 - Introdução  -->
                        <div id="introduction">
                            <h6>1.0 - Introdução</h6>
                            <strong>Comandos e conceitos básicos</strong><br><br>
                            <ul>
                                <li>
                                    <strong>clone:</strong> Este comando serve para <strong>criar um repositório na sua máquina local</strong> mesmo que seja uma cópia de um repositório em um servidor, no caso o github. Em outras palavras, o comando clone faz download do código que está no servidor, mas ao mesmo tempo cria um repositório na sua máquina local.
                                </li><br>
                                <li>
                                    <strong>branch:</strong> Um ramo do projeto, uma divisão do projeto se baseando na principal(master) porém que esteja seguindo linhas de pensamento diferentes Ex:
                                    <ul>
                                        <li>Correção de bugs de uma versão que está online estaria em uma Branch.</li>
                                        <li>A atualização ou criação de um outro layout estaria em outra Branch.</li>
                                        <li>A criação de alguma nova funcionalidade poderia estar em outra Branch diferente das anteriores.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>checkout:</strong> Este comando serve para você escolher em qual <strong>branch</strong> você está agindo agora. Ou seja, você configura qual a <strong>branch vigente</strong> no <strong>repositório local</strong>.
                                </li><br>
                                <li>
                                    <strong>add:</strong> Este comando adiciona um arquivo ou diretório no <strong>repositório local</strong>, na <strong>branch vigente</strong> do mesmo, é como você dissesse pro repositório:<br>
									<blockquote>
										"Hey repositório, eu tenho um arquivo/diretório novo aqui e quero que você guarde ele para mim, segura ele, mas não guarda ainda não tá?"</strong><br>
									</blockquote>
									<ul id="git-reset">
										<li>
											<h6>git reset</h6>
											Você pode desfazer <strong>git add</strong> antes de um commit com o <strong>git reset</strong>:
											<br>
											<blockquote>
												$ git reset < file > <br>
											</blockquote>
										</li>
									</ul>

									Repare que o repositório não terá ainda teu arquivo, ele apenas saberá que ele existe.
									
                                    <ul>
                                        <li> adiciona um arquivo/diretório no repositório local;</li>
                                        <li> Na branch vigente;</li>
                                        <li> Segura um arquivo/diretório mas não guarda no repositório ainda.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>commit:</strong> Agora sim, você está entregando o arquivo/diretório para que o repositório guarde-o. Mas novamente, vale notar que este arquivo só está versionado (guardado), no <strong>repositório local</strong>, na <strong>branch vigente</strong>.
                                    <ul>
                                        <li>No <strong>repositório local</strong></li>
                                        <li>Na <strong>branch vigente</strong></li>
                                    </ul>
                                </li><br>
                                <li>
                                   <strong>pull:</strong> Este comando baixa os documentos mais atuais do servidor(ex: GitHub), para o <strong>repositório local</strong> e <strong>branch vigente</strong>.
                                </li><br>
                                <li>
                                    <strong>push:</strong> E agora, não menos importante, o grande comando push. Este comando é semelhante ao comando commit, mas agora ele envia tudo que está no seu <strong>repositório local</strong> e <strong>branch vigente</strong> para o repositório do servidor(Ex: github). Ou seja, só após você executar este comando que as pessoas do projeto conseguirão ver o que você fez até então!
                                    <ul>
                                        <li>Primeiro, o comando <strong>add</strong> pede para guardar um arquivo/diretório;</li>
                                        <li>Segundo, o comando <strong>commit -m "msg"</strong> guarda o/os arquivo/diretório no <strong>repositório local</strong> e <strong>branch vigente</strong>;</li>
                                        <li>Terceiro, o comando <strong>push</strong> envia tudo que está no seu <strong>repositório local</strong> e <strong>branch vigente</strong> para o repositório do servidor(Ex: github).</li>
                                    </ul>
                                </li><br>
                            </ul>

                            <strong>Fluxos de trabalho Centralizado</strong><br>

                            O fluxo de trabalho centralizado é o mais familiar para aqueles que vieram de outras ferramentas de versionamento mais antigas, como o CVS ou SVN. Nele você tem apenas um único servidor, e diversas pessoas trabalhando em seus repositórios locais e enfim subindo os documentos para o repositório principal(servidor).<br><br>
                            Explicando detalhadamente desde o inicio da vida de um repositório com <strong>Fluxo de trabalho centralizado</strong>, ele funcionaria desta forma:<br><br>
                            <table class="table table-striped table-bordered">
                                <tr>
                                    <td>
                                    <strong>Step:01</strong>
                                    </td>
                                    <td>
                                    É criado um repositório novo no servidor para o projeto <strong>X</strong>.
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                    <strong>Step:02</strong>
                                    </td>
                                    <td>
                                    Cada membro da equipe <strong>clona</strong> o repositório em sua máquina local.
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                    <strong>Step:03</strong>
                                    </td>
                                    <td>
                                    Para cada <strong>tarefa</strong> ou <strong>subtarefa</strong> que for feita, cada membro da equipe cria uma nova <strong>branch</strong> em seu repositório local e logo em seguida efetua um <strong>checkout</strong> para a nova branch criada.
                                    </td>
                                </tr>  
                                <tr>
                                    <td>
                                    <strong>Step:04</strong>
                                    </td>
                                    <td>
                                    Então cada um segue com sua atividade e a medida que desejar, a pessoa <strong>adiciona(add)</strong> e realiza <strong>commit</strong> de suas alterações, para que o repositório local guarde o histórico do que foi feito. Este passo é executado até que a tarefa ou subtarefa esteja concluida.
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                    <strong>Step:05</strong>
                                    </td>
                                    <td>
                                    Após a tarefa estar concluido e feito o <strong>commit</strong> no repositório local, o membro da equipe faz <strong>checkout</strong> para a branch principal, no caso, a </strong>branch master</strong> e realiza o comando <strong>pull</strong> para atualizar seu repositório local com os documentos mais novos feitos pela equipe.
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                    <strong>Step:06</strong>
                                    </td>
                                    <td>
                                    Feito o <strong>pull</strong>, deve-se então realizar o <strong>merge</strong> da branch criada no <strong>3º passo</strong> com a branch <strong>master</strong>, juntando assim os documentos em seu repositório local.
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                    <strong>Step:07</strong>
                                    </td>
                                    <td>
                                    Por fim, é realizado o comando <strong>push</strong> para que suas alterações sejam enviadas ao repositório central(servidor).
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                    <strong>Step:08</strong>
                                    </td>
                                    <td>
                                    Após feito o <strong>push</strong>, a pessoa pode apagar a branch criada (se desejar) e então deve escolher uma nova <strong>tarefa</strong> ou <strong>subtarefa</strong> e voltar ao <strong>3º passo</strong>. E isso continua até que o projeto esteja concluído.
                                    </td>
                                </tr>
                            </table>
                            Este fluxo se chama <strong>Fluxo de Trabalho Centralizado</strong>, pois temos um único repositório servidor servindo como centralizador do código entre as equipes de desenvolvimento. É um fluxo bastante utilizado em mundo corporativo onde temos uma equipe pequena trabalhando. Porém mostra-se inviável em grandes projetos Open-Source, como por exemplo o projeto do kernel do GNU Linux.
                        </div>
                        <!-- /Fim da seção 1.0 - Introdução  -->


                        <br><br>
                        <!-- Início da seção 1.1 - Estados -->
                        <div id="estados">
                            <h6>1.1 - Estados</h6>
                            Agora preste atenção. Essa é a coisa mais importante pra se lembrar sobre <strong>Git</strong> se você quiser que o resto do seu aprendizado seja tranquilo. Git faz com que seus arquivos sempre estejam em um dos três estados fundamentais:
                            <br><br>
                            <ul>
                                <li>consolidado <strong>(committed)</strong>;</li>
                                <li>modificado <strong>(modified)</strong>;</li>
                                <li>preparado <strong>(staged)</strong>.</li>
                            </ul>

                            <strong>Consolidado(comitted):</strong><br>
                            Dados são ditos consolidados quando estão seguramente armazenados em sua <strong>base de dados local</strong>.
                            <br><br>

                            <strong>Modificado(modified):</strong><br>
                            Modificado trata de um arquivo que sofreu mudanças mas que ainda não foi consolidado na base de dados.
                            <br><br>

                            <strong>preparado(staged):</strong><br>
                            Um arquivo é tido como preparado quando você marca um arquivo modificado em sua versão corrente para que ele faça parte do snapshot do próximo commit (consolidação).
                            <br><br>

                            Isso nos traz para as três seções principais de um projeto do Git: 
                            <br>
                            
                            <ul>
                                <li>O diretório do Git <strong>(git directory, repository)</strong></li>
                                <li>O diretório de trabalho <strong>(working directory)</strong></li>
                                <li>A área de preparação <strong>(staging area)</strong></li>
                            </ul>
                            <br><br>

                            <img class="img-fluid mx-auto d-block" src="https://git-scm.com/book/en/v2/images/areas.png" alt="git-estados">
                            <br>

                            <strong>git directory(repository):</strong><br>
                            É o diretório do Git <strong>local</strong> onde o Git armazena os metadados e o banco de objetos de seu projeto. Esta é a parte mais importante do Git, e é a parte copiada quando você clona um repositório de outro computador.
                            <br><br>

                            <strong>Working Directory:</strong><br>
                            O diretório de trabalho é um único checkout de uma versão do projeto. Estes arquivos são obtidos a partir da base de dados comprimida no diretório do Git e colocados em disco para que você possa utilizar ou modificar.  
                            <br><br>

                            <strong>Staging Area:</strong><br>
                            A área de preparação é um simples arquivo, geralmente contido no seu diretório Git, que armazena informações sobre o que irá em seu próximo commit. É bastante conhecido como índice (index), mas está se tornando padrão chamá-lo de área de preparação(Staging Area).

                        </div>
                        <!-- /Fim da seção 1.1 - Estados -->


                        <br><br>
                        <!-- Início da seção 1.2 - Configuração inicial -->
                        <div id="setting">
                            <h6>1.2 - Configuração inicial</h6>
                            <strong>Sua Identidade</strong>
                            <br>

                            A primeira coisa que você deve fazer quando instalar o Git é definir o seu <strong>nome de usuário</strong> e <strong>endereço de e-mail</strong>. Isso é importante porque todos os commits no Git utilizam essas informações, e está imutavelmente anexado nos commits que você realiza:
                            <br><br>

                            <blockquote>
                                $ git config --global user.name "drigols"<br>
                                $ git config --global user.email drigols.creative@gmail.com
                            </blockquote>
                            <br>

                            Relembrando, você só precisará fazer isso uma vez caso passe a opção <strong>--global</strong>, pois o Git sempre usará essa informação para qualquer coisa que você faça nesse sistema. Caso você queira sobrepor estas com um nome ou endereço de e-mail diferentes para projetos específicos, você pode executar o comando <strong>sem a opção --global</strong> quando estiver no próprio projeto.
                            <br><br>

                            <strong>Verificando Suas Configurações</strong>  
                            <br>

                            Caso você queira verificar suas configurações, você pode utilizar o comando <strong>git config --list</strong> para listar todas as configurações que o Git encontrar naquele momento:
                            <br><br>

                            <blockquote>
                                user.name=drigols<br>
                                user.email=drigols.creative@gmail.com<br>
                                core.editor=emacs<br>
                                core.repositoryformatversion=0<br>
                                core.filemode=true<br>
                                core.bare=false<br>
                                core.logallrefupdates=true<br>
                            </blockquote>

                            Você também pode verificar qual o valor que uma determinada chave tem para o Git digitando <strong>git config {key}</strong>:  
                            <br><br>
                            <blockquote>
                                $ git config user.name<br>
                                drigols<br>
                            </blockquote>
                        </div>
                        <!-- /Fim da seção 1.2 - Configuração inicial -->


                        <br><br>
                        <!-- Início da seção 2.0 - Commit StyleGuide  -->
                        <div id="commit-styleguide">
                            <h6>2.0 - Commit StyleGuide</h6>

                            Uma coisa muito importante que a maioria dos desenvolvedores esquecem é a parte dos <strong>emoji</strong>. Isso deixa o seu commit bem mais legível visto que de cara já da para notar o que aconteceu com aquele commit.
                            <br><br>

                            <strong>Examples:</strong>
                            <br><br>

                            <!-- Início da tabela de emoji -->
                            <table class="table table-striped table-bordered">
                                <tr>
                                    <th>Code</th>
                                    <th>Commit type</th>
                                </tr>
                                <tr>
                                    <td>:tada:</td>
                                    <td>Commit inicial</td>
                                </tr>
                                <tr>
                                    <td>:art:</td>
                                    <td>Quando melhorar a estrutura/formato do código</td>
                                </tr>
                                <tr>
                                    <td>:racehorse:</td>
                                    <td>Quando melhorar a performance</td>
                                </tr>
                                <tr>
                                    <td>:memo:</td>
                                    <td>Quando escrever alguma documentação</td>
                                </tr>
                                <tr>
                                    <td>:bug:</td>
                                    <td>Quando corrigir um bug</td>
                                </tr>
                                <tr>
                                    <td>:fire:</td>
                                    <td>Quando remover códigos ou arquivos</td>
                                </tr>
                                <tr>
                                    <td>:green_heart:</td>
                                    <td>Quando corrigir uma build no CI</td>
                                </tr>
                                <tr>
                                    <td>:white_check_mark:</td>
                                    <td>Quando adicionar testes</td>
                                </tr>
                                <tr>
                                    <td>:lock:</td>
                                    <td>Quando melhorar a segurança</td>
                                </tr>
                                <tr>
                                    <td>:arrow_up:</td>
                                    <td>Quando der um upgrade em depedências</td>
                                </tr>
                                <tr>
                                    <td>:arrow_down:</td>
                                    <td>Quando der um downgrade em dependências</td>
                                </tr>
                                <tr>
                                    <td>:poop:</td>
                                    <td>Descontinuado</td>
                                </tr>
                                <tr>
                                    <td>:construction:</td>
                                    <td>Em construção</td>
                                </tr>
                                <tr>
                                    <td>:rocket:</td>
                                    <td>Nova feature</td>
                                </tr>
                                <tr>
                                    <td>:see_no_evil:</td>
                                    <td>Gambiarra</td>
                                </tr>
                                <tr>
                                    <td>:gift:</td>
                                    <td>Nova versão</td>
                                </tr>
                            </table>
                            <!-- /Fim da tabela de emoji -->
                            <br>

                            <a href="https://gist.github.com/rxaviers/7360908" target="blank">Aqui</a> você também pode encontrar vários outros emoji.
                            <br><br>

                            <strong>Três coisas importantes em um commit</strong>
                            <br><br>

                            <ul>
                                <li>Tag(quando necessário);</li>
                                <li>Linha de resumo(máximo de 72 caracteres);</li>
                                <li>Descrição do commit.</li>
                            </ul>

                            <strong>TAGS PERMITIDAS</strong>
                            <br><br>

                            <ul>
                                <li>[tag]: Criação de uma tag.</li>
                                <li>[-tag]: Remoção de uma tag.</li>
                                <li>[branch]: Criação de um branch.</li>
                                <li>[-branch]: Remoção de um branch.</li>
                                <li>[merge]: Junção de códigos, ponto crítico.</li>
                            </ul>

                            <strong>Linha de Resumo</strong>
                            <br><br>

                            A primeira linha do commit deve ser um resumo do commit e tem 2 pontos importantes:
                            <br>
                            <ul>
                                <li>Deve ter no máximo 72 caracteres;</li>
                                <li>Não termina a linha de resumo com pontuação.</li>
                            </ul>

                            Escreva a linha de resumo e a descrição de modo <strong>imperativo</strong>, como se estivesse comandando alguém. Exemplo:
                            <br>

                            <ul>
                                <li>Adiciona</li>
                                <li>Remove</li>
                                <li>Atualiza</li>
                            </ul>

                            O contrário seria: <strong>"adicionado"</strong>, <strong>"removido"</strong>, <strong>"atualizado"</strong>(Não faça isso).
                            <br><br>
                            
                            <strong>Exemplo:</strong>  
                            <br>

                            <blockquote>
                                git commit -m ":tada: Initial commit<br>
                                ><br>
                                > Esse é meu primeiro commit...<br>
                                > ...essa nova linha é para não deixar o seu commit muito longo na horizontal."<br>
                            </blockquote>

                            <strong>Output:</strong>  
                            <br>

                            <blockquote>
                                [master dde03e0] :tada: Initial commit <br>
                                1 file changed, 0 insertions(+), 0 deletions(-)<br>
                                create mode 100644 index.html<br>
                            </blockquote>

                            Agora você acabou de criar o seu primeiro commit! Você pode ver que o commit te mostrou uma saída sobre ele mesmo:  
                            
                            <ul>
                                <li>Qual o branch que recebeu o commit <strong>(master)</strong>;</li>
                                <li>Qual o checksum SHA-1 que o commit teve <strong>(dde03e0)</strong>;</li>
                                <li>Quantos arquivos foram alterados <strong>(1 file changed, 0 insertions(+), 0 deletions(-))</strong>;</li>
                                <li>Estatísticas a respeito das linhas adicionadas e removidas no commit.</li>
                            </ul>

                            <strong>Modificando Seu Último Commit</strong>
                            <br>
                            
                            Uma das situações mais comuns para desfazer algo, acontece quando você faz o commit muito cedo e possivelmente esqueceu de adicionar alguns arquivos, ou você bagunçou sua mensagem de commit. Se você quiser tentar fazer novamente esse commit, você pode executá-lo com a opção <strong>--amend</strong>: 

                            <blockquote>
                                $ git commit --amend
                            </blockquote>

                            Esse comando pega sua área de seleção e a utiliza no commit. Se você não fez nenhuma modificação desde seu último commit (por exemplo, você rodou esse comando imediatamente após seu commit anterior), seu snapshot será exatamente o mesmo e tudo que você mudou foi sua mensagem de commit.
                            <br>
                        </div>
                        <!-- /Fim da seção 2.0 - Commit StyleGuide -->


                        <br><br>
                        <!-- Início da seção 2.1 - Git log  -->
                        <div id="git-log">
                            <h6>2.1 - Git log</h6>

                            <strong>Visualizando o Histórico de Commits</strong>
                            <br><br>

                            Depois que você tiver criado vários commits, ou se clonou um repositório com um histórico de commits existente, você provavelmente vai querer ver o que aconteceu. A ferramente mais básica e poderosa para fazer isso é o comando <strong>git log</strong>.  
                            <br>

                            <strong>Exemplo:</strong>
                            <br><br>

                            <blockquote>
                                git clone git://github.com/schacon/simplegit-progit.git
                            </blockquote>

							Quando você executar git log neste projeto, você deve ter uma saída como esta:
							<br><br>

							<blockquote>
									$ git log <br>
									commit ca82a6dff817ec66f44342007202690a93763949 <br>
									Author: drigols <drigols.creative@gmail.com> <br>
									Date:   Mon Mar 17 21:52:11 2008 -0700 <br>
									<br>
										changed the verison number <br>
									<br>
									commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 <br>
									Author: drigols <drigols.creative@gmail.com> <br>
									Date:   Sat Mar 15 16:40:33 2008 -0700 <br>
									<br>
										removed unnecessary test code <br>
									<br>
									commit a11bef06a3f659402fe7563abf99ad00de2209e6 <br>
									Author: drigols <drigols.creative@gmail.com> <br>
									Date:   Sat Mar 15 10:31:28 2008 -0700 <br>
									<br>
										first commit <br>
							</blockquote>

							Por padrão, sem argumentos, <strong>git log</strong> lista os commits feitos naquele repositório em ordem cronológica reversa. Isto é, os commits mais recentes primeiro. Como você pode ver, este comando lista:  

							<ul>
								<li>Cada commit;</li>
								<li>Seu checksum SHA-1;</li>
								<li>O nome e e-mail do autor;</li>
								<li>A data;</li>
								<li>A mensagem do commit.</li>
							</ul>
                        </div>
                        <!-- /Fim da seção 2.1 - Git log -->


						<br><br>
						<!-- Início da seção 2.2 - Trabalhando com remotos -->
						<div id="trabalhando-com-remotos">
							<h6>2.2 - Trabalhando com remotos (git fetch)</h6>
							<strong>Exibindo Seus Remotos</strong>
							<br><br>

						  	Para ver quais servidores remotos você configurou, você pode executar o comando <strong>git remote</strong>. Ele lista o nome de cada remoto que você especificou. Se você tiver clonado seu repositório, você deve pelo menos ver um chamado <strong>origin</strong> — esse é o nome padrão que o Git dá ao servidor de onde você fez o clone.
							<br><br>

							<blockquote>
								$ cd test <br>
								$ git remote <br>
								origin <br>
							</blockquote>

							Você também pode especificar <strong>-v</strong>, que mostra a URL que o Git armazenou para o nome do remoto:
							<br>
							
							<blockquote>
								$ git remote -v <br>
								origin  git://github.com/schacon/ticgit.git (fetch) <br>
								origin  git://github.com/schacon/ticgit.git (push) <br>
							</blockquote>

							Se você tem mais de um remoto, o comando lista todos. Por exemplo, meu repositório Grit se parece com isso.
							<br>

							<blockquote>
								$ cd grit <br>
								$ git remote -v <br>
								bakkdoor  git://github.com/bakkdoor/grit.git <br>
								cho45     git://github.com/cho45/grit.git <br>
								defunkt   git://github.com/defunkt/grit.git <br>
								koke      git://github.com/koke/grit.git <br>
								origin    git@github.com:mojombo/grit.git <br>
							</blockquote>

							Isso significa que podemos puxar contribuições de qualquer um desses usuários muito facilmente. Mas note que somente o <strong>remoto origin</strong> é uma URL SSH, sendo o <strong>único pra onde eu posso fazer o push</strong>.
							<br><br>

							<strong>Adicionando Repositórios Remotos</strong>  
							<br>

							Para adicionar um novo repositório remoto no Git com um nome curto, para que você possa fazer referência facilmente, execute <strong>git remote add [nomecurto] [url]</strong>:  
							<br><br>

							<blockquote>
								$ git remote <br>
								origin <br>
								$ git remote add pb git://github.com/paulboone/ticgit.git <br>
								$ git remote -v <br>
								origin    git://github.com/schacon/ticgit.git <br>
								pb    git://github.com/paulboone/ticgit.git <br>
							</blockquote>

							Agora você pode usar a string <strong>pb</strong> na linha de comando em lugar da URL completa. Por exemplo, se você quer fazer o fetch de todos os dados de Paul que você ainda não tem no seu repositório, você pode executar <strong>git fetch pb</strong>:
							<br><br>

							<blockquote>
								$ git fetch pb <br>
								remote: Counting objects: 58, done. <br>
								remote: Compressing objects: 100% (41/41), done. <br>
								remote: Total 44 (delta 24), reused 1 (delta 0) <br>
								Unpacking objects: 100% (44/44), done. <br>
								From git://github.com/paulboone/ticgit <br>
								 * [new branch]      master     -> pb/master <br>
								 * [new branch]      ticgit     -> pb/ticgit <br>
							</blockquote>

							O branch master de Paul é localmente acessível como pb/master — você pode fazer o merge dele em um de seus branches, ou fazer o check out de um branch local a partir deste ponto se você quiser inspecioná-lo.
							<br><br>

							<strong id="fetch">Fazendo o Fetch e Pull de Seus Remotos</strong>
							<br>
							
							Como você acabou de ver, para pegar dados dos seus projetos remotos, você pode executar:
							<br><br>
							<blockquote>
								$ git fetch [nome-remoto] <br>
							</blockquote>

							Esse comando <strong>vai até o projeto remoto e pega todos os dados que você ainda não tem</strong>. Depois de fazer isso, <u>você deve ter referências para todos os branches desse remoto</u>, onde você pode fazer o <strong>merge</strong> ou <strong>inspecionar</strong> a qualquer momento.  
							<br><br>

						  	Se você clonar um repositório, o comando automaticamente adiciona o remoto com o nome origin. Então, <strong>git fetch origin</strong> busca qualquer novo trabalho que foi enviado para esse servidor desde que você o clonou (ou fez a última busca).
							<br><br>

							<u><strong>OBSERVAÇÃO:</strong></u>  
							<br>
							É importante notar que o comando <strong>fetch</strong> traz os dados para o seu <strong>repositório local</strong> — ele não faz o merge automaticamente com o seus dados ou modifica o que você está trabalhando atualmente. Você terá que fazer o merge manualmente no seu trabalho quando estiver pronto.
							<br><br>

							<strong>Git pull</strong>
							<br>
							Se você tem um branch configurado para acompanhar um branch remoto, você pode usar o comando <strong>git pull</strong> para automaticamente fazer o <strong>fetch</strong> e o <strong>merge</strong> de um branch remoto no seu <strong>branch atual</strong>.
							<br><br>
							
							Executar <strong>git pull</strong> geralmente busca os dados do servidor de onde você fez o clone originalmente e automaticamente tenta fazer o merge dele no código que você está trabalhando atualmente.  
							<br><br>
							
							<strong>Pushing para seus remotos</strong>  
							<br>
							Quando o seu projeto estiver pronto para ser compartilhado, você tem que enviá-lo para a fonte. O comando para isso é simples:  
							<br>

							<blockquote>
								git push [nome-remoto] [branch] <br>
							</blockquote>

							Se você quer enviar o seu branch master para o servidor origin, então você pode rodar o comando abaixo para enviar o seu trabalho para o sevidor:  

							<blockquote>
								$ git push origin master <br>
							</blockquote>
							
						   	Este comando funciona apenas se você clonou de um servidor que você têm permissão para escrita, e se mais ninguém enviou dados no meio tempo. Se você e mais alguém clonarem ao mesmo tempo, e você enviar suas modificações após a pessoa ter enviado as dela, o seu push será rejeitado. <u>Antes, você terá que fazer um pull das modificações deste outro alguém, e incorporá-las às suas para que você tenha permissão para enviá-las</u>.  
							<br><br>
							
							<strong>Removendo e renomeando remotos</strong>  
							<br>

							Se você quiser renomear uma referência, em versões novas do Git você pode rodar <strong>git remote rename</strong> para modificar um apelido de um remoto. Por exemplo, se você quiser renomear pb para paul, você pode com <strong>git remote rename</strong>:  
							<br>
							
							<blockquote>
								$ git remote rename pb paul <br>
								$ git remote <br>
								origin <br>
								paul <br>
							</blockquote>
							
							É válido mencionar que isso modifica também os nomes dos branches no servidor remoto. O que costumava ser referenciado como <strong>pb/master</strong> agora é <strong>paul/master</strong>.  
							<br><br>

						  	Se você quiser remover uma referência por qualquer razão — você moveu o servidor ou não está mais usando um mirror específico, ou talvez um contribuidor não está mais contribuindo — você usa <strong>git remote rm</strong>:  
							<br>

							<blockquote>
								$ git remote rm paul <br>
								$ git remote <br>
								origin <br>
							</blockquote>
						</div>
						<!-- /Fim da seção 2.2 - Trabalhando com remotos -->


						<br><br>
						<!-- Início da seção 3.0 - Branch -->
						<div id="branch">
							<h6>3.0 - Branch</h6>
							
							Quando você faz um commit no Git, o Git guarda um objeto commit que contém:  
							
							<ul>
								<li>Um ponteiro para o snapshot do conteúdo que você colocou na área de seleção;</li>
								<li>O autor;</li>
								<li>Os metadados da mensagem;</li>
								<li>Zero ou mais ponteiros para o commit ou commits que são pais deste commit.</li>
							</ul>
  
							Para visualizar isso, vamos supor que você tenha um diretório contendo três arquivos, e colocou todos eles na área de seleção e fez o commit. Colocar na área de seleção cria o <strong>checksum</strong> de cada arquivo, armazena esta versão do arquivo no repositório Git (o Git se refere a eles como blobs), e acrescenta este checksum à área de seleção:
							<br><br>

							<blockquote>
								$ git add README test.rb LICENSE <br>
								$ git commit -m 'commit inicial do meu projeto'
							</blockquote>
							
							Quando você cria um commit executando <strong>git commit</strong>, o Git calcula o checksum de cada subdiretório e armazena os objetos de árvore no repositório Git. O Git em seguida, <strong>cria um objeto commit</strong> que tem os metadados e <strong>um ponteiro para a árvore do projeto raiz</strong>, então ele pode recriar este snapshot quando necessário.  
							<br><br>
							
							Seu repositório Git agora contém cinco objetos:  
							
							<ul>
								<li>1º Um blob para o conteúdo de cada um dos três arquivos;</li>
								<li>2º Uma árvore que lista o conteúdo do diretório e especifica quais nomes de arquivos são armazenados em quais blobs;</li>
								<li>3º Um commit com o ponteiro para a raiz dessa árvore com todos os metadados do commit.</li>
							</ul>

							Conceitualmente, os dados em seu repositório Git se parecem como na figura abaixo:  
							<br>
							
							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0301-tn.png" alt="">
							<br>

							Se você modificar algumas coisas e fizer um commit novamente, o próximo commit armazenará um ponteiro para o commit imediatamente anterior. Depois de mais dois commits, seu histórico poderia ser algo como a figura abaixo:  
							<br><br>

							<img class="img-fluit mx-auto d-block" src="https://git-scm.com/figures/18333fig0302-tn.png" alt="">
							<br>

							<strong>Branching</strong>  
							<br>

							Um <strong>branch</strong> no Git é simplesmente um leve ponteiro móvel para um desses commits. O nome do branch padrão no Git é master. Como você inicialmente fez commits, você tem um branch principal (master branch) que aponta para o último commit que você fez. Cada vez que você faz um commit ele avança automaticamente.  
							<br>

							<img class="img-fluit mx-auto d-block" src="https://git-scm.com/figures/18333fig0303-tn.png" alt="">
							<br><br>

							<strong><u>OBSERVAÇÃO:</u></strong>
							<br>
							Lembram que quando utilizamos o comando <strong>git log</strong> ele retorna a lista de commits da branch vigente? Lembram que ele retorna os commits da ordem mais recente, ou seja, do mais recente até os mais antigos. Então, a imagem acima demonstrar isso na prática onde a <strong>master</strong> está apontando para o último commit(mais recente).  
							<br><br>

							<strong>Nova Branch</strong>
							<br>

							O que acontece se você criar um novo branch? Bem, isso cria um novo ponteiro para que você possa se mover. Vamos dizer que você crie um novo branch chamado <strong>testing</strong>. Você faz isso com o comando <strong>git branch</strong>:  
							<br><br>
							
							<blockquote>
								$git branch testing <br>
							</blockquote>
								
							Isso cria um novo ponteiro para o mesmo commit em que você está no momento, veja na figura abaixo:  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0304-tn.png" alt="">  
							<br><br>

							Como o Git sabe o branch em que você está atualmente? Ou seja, como ele sabe se eu estou na branch <strong>master</strong> ou <strong>testing</strong>? Ele mantém um ponteiro especial chamado <strong>HEAD</strong>.  
							<br>

							<img class="img-fluid  mx-auto d-block" src="https://git-scm.com/figures/18333fig0305-tn.png" alt="">
							<strong>HEAD apontando para o branch em que você está.</strong>  
							<br><br>
							
							No Git, este é um ponteiro para o <strong>branch local</strong> em que você está no momento. Neste caso, você ainda está no master. O comando git branch só criou um novo branch — ele não mudou para esse branch.  
							<br><br>

							<strong>Mudando de Branch</strong>
							<br>
								
							Para mudar para um branch existente, você executa o comando <strong>git checkout</strong>. Vamos mudar para o novo branch <strong>testing</strong>:  
							<br><br>
							
							<blockquote>
								$ git checkout testing <br>
							</blockquote>
								
							Isto move o <strong>HEAD</strong> para apontar para o branch testing, veja a figura abaixo:  
							<br>
							
							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0306-tn.png" alt="">  
							<strong>O HEAD aponta para outro branch quando você troca de branches.</strong>  
							<br><br>
							
							Qual é o significado disso? Bem, vamos fazer um outro commit:  
							<br><br>
							
							<blockquote>
								$ touch test-02.rb <br>
								$ git commit -a -m 'fiz uma alteração' <br>
							</blockquote>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0307-tn.png" alt="">  
							<strong>O branch para o qual HEAD aponta avança com cada commit(Lembra que uma branch no Git é simplesmente um leve ponteiro móvel para um desses commits, então, o que acontece é que a cada commit essa branching vai avançando).</strong>  
							<br><br>

							Isso é interessante, porque agora o seu branch testing avançou, mas o seu branch master ainda aponta para o commit em que estava quando você executou <strong>git checkout</strong> para trocar de branch. Vamos voltar para o branch master:  
							<br><br>

							<blockquote>
								$ git checkout master
							</blockquote>

							Veja a figura abaixo o resultado:  
							<br>
							
							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0308-tn.png" alt="">  
							<strong>O HEAD se move para outro branch com um checkout.</strong>  
							<br><br>

							Esse comando fez duas coisas:  
							
							<ul>
								<li>Ele alterou o ponteiro HEAD para apontar novamente para o branch master;</li>
								<li>E reverteu os arquivos em seu diretório de trabalho para o estado em que estavam no snapshot para o qual o master apontava.</li>
							</ul>
							
							Isto significa também que as mudanças feitas a partir deste ponto em diante, irão divergir de uma versão anterior do projeto. Ele essencialmente "volta" o trabalho que você fez no seu <strong>branch testing</strong>, temporariamente, de modo que você possa ir em uma direção diferente.  
							<br><br>

							Vamos fazer algumas mudanças e fazer o commit novamente:  
							<br>

							<blockquote>
								$ vim test.rb <br>
								$ git commit -a -m 'fiz outra alteração' <br>
							</blockquote>

							Agora o histórico do seu projeto divergiu. Você criou e trocou para um branch, trabalhou nele, e então voltou para o seu branch principal(master) e trabalhou mais. Ambas as mudanças são isoladas em branches distintos: você pode alternar entre os branches e fundi-los (merge) quando estiver pronto. E você fez tudo isso simplesmente com os comandos <strong>branch</strong> e <strong>checkout</strong>.  
							<br>

							Veja na figura abaixo como fica essas divergências(fluxos diferentes de trabalho):  
							<br><br>
							
							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0309-tn.png" alt="">  
							<strong>O histórico dos branches diverge.</strong>
							<br><br>
							
							<strong><U>OBSERVAÇÃO:</U></strong>
							<br>
							Um branch em Git é na verdade um arquivo simples que contém os 40 caracteres do checksum SHA-1 do commit para o qual ele aponta, os branches são baratos para criar e destruir. Criar um novo branch é tão rápido e simples como escrever 41 bytes em um arquivo (40 caracteres e uma quebra de linha).
						</div>
						<!-- /Fim da seção 3.0 - Branch  -->


						<br><br>
						<!-- Início da seção 3.1 - Merging -->
						<div id="merging">
							<h6>3.1 - Merging</h6>
							<br>
							Vamos ver um exemplo simples de uso de <strong>branch</strong> e <strong>merge</strong> com um fluxo de trabalho que você pode usar no mundo real. Você seguirá esses passos:  
							
							<ul>
								<li>1. Trabalhar em um web site.</li>
								<li>2. Criar um branch para uma nova história em que está trabalhando.</li>
								<li>3. Trabalhar nesse branch.</li>
							</ul>

							Nesse etapa, você receberá um telefonema informando que outro problema crítico existe e precisa de correção. Você fará o seguinte:  
							<br>

							<ul>
								<li>1. Voltar ao seu branch de produção.</li>
								<li>2. Criar um branch para adicionar a correção.</li>
								<li>3. Depois de testado, fazer o merge do branch da correção, e enviar para produção.</li>
								<li>4. Retornar à sua história anterior e continuar trabalhando.</li>
							</ul>

							<strong>Branch Básico</strong>
							<br>
								
							Primeiro, digamos que você esteja trabalhando no seu projeto e já tem alguns commits. Veja na figura abaixo:  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0310-tn.png" alt="">
							<strong>Um histórico de commits pequeno e simples(Lembre que esses commit apontam em sequência do mais recente para o mais antigo).</strong>  
							<br><br>

							Você decidiu que irá trabalhar na tarefa <strong>(issue) #53</strong> do gerenciador de bugs ou tarefas que sua empresa usa. Para deixar claro, Git não é amarrado a nenhum gerenciador de tarefas em particular; mas já que a tarefa <strong>#53</strong> tem um foco diferente, você criará um branch novo para trabalhar nele.  
							<br><br>

							Para criar um branch e mudar para ele ao mesmo tempo, você pode executar o comando <strong>git checkout</strong> com a opção <strong>-b</strong>:  
							<br><br>
							
							<blockquote>
								$ git checkout -b iss53 <br>
								Switched to a new branch "iss53" <br>
							</blockquote>

							Isso é um atalho para:
							<br>

							<blockquote>
								$ git branch iss53  <br>
								$ git checkout iss53  <br>
							</blockquote>

							Veja a figura abaixo para ficar melhor com uma ilustração do fluxo:  
							<br><br>
							
							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0311-tn.png" alt="">
							<br><br>

							Você trabalha no seu web site e faz alguns commits:  
							<br>
							
							<blockquote>
								$ touch index.html <br>
								$ git commit -a -m 'adicionei um novo rodapé [issue 53]' <br>
							</blockquote> 
								
							Ao fazer isso o branch <strong>iss53</strong> avançará, pois você fez o checkout dele <strong>(isto é, seu HEAD está apontando para ele)</strong>, veja na figura abaixo:  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0312-tn.png" alt="">  
							<br><br>

							Nesse momento você recebe uma ligação dizendo que existe um problema com o web site e você deve resolvê-lo imediatamente. Com Git, você não precisa fazer o deploy de sua correção junto com as modificações que você fez no <strong>iss53</strong>, e você não precisa se esforçar muito para reverter essas modificações antes que você possa aplicar sua correção em produção. Tudo que você tem a fazer é voltar ao seu <strong>branch master</strong>.  
							<br><br>

							No entanto, antes de fazer isso, note que seu <strong>diretório de trabalho(Working Directory)</strong> ou <strong>área de seleção</strong> tem modificações que não entraram em commits e que estão gerando conflitos com o branch que você está fazendo o checkout, Git não deixará você mudar de branch.  
							<br><br>

							Existem maneiras de contornar esta situação (isto é, incluir e fazer o commit). Por enquanto, você fez o commit de todas as suas modificações, então você pode mudar para o seu branch master:  
							<br>
							
							<blockquote>
								$ git checkout master <br>
								Switched to branch "master" <br>
							</blockquote>

							Nesse ponto, o diretório do seu projeto está exatamente do jeito que estava antes de você começar a trabalhar na tarefa <strong>#53</strong>, e você se concentra na correção do erro.  
							<br><br>

							Em seguida, você tem uma correção para fazer. Vamos criar um branch para a correção <strong>(hotfix)</strong> para trabalhar até a conclusão:  
							<br><br>
							
							<blockquote>
								$ git checkout -b 'hotfix' <br>
								Switched to a new branch "hotfix" <br>
								$ touch index.html <br>
								$ git commit -a -m 'consertei o endereço de email' <br>
								[hotfix]: created 3a0874c: "consertei o endereço de email" <br>
								1 files changed, 0 insertions(+), 1 deletions(-) <br>
							</blockquote>

							Veja o resultado na figura abaixo:  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0313-tn.png" alt="">  
							<strong>branch de correção (hotfix) baseado num ponto de seu branch master.</strong>  
							<br><br>

							Você pode rodar seus testes, tenha certeza que a correção é o que você quer, e faça o merge no seu branch master para fazer o deploy em produção. Você faz isso com o comando <strong>git merge</strong>:  
							<br>
							
							<blockquote>
								$ git checkout master <br>
								$ git merge hotfix <br>
								Updating f42c576..3a0874c <br>
								Fast forward <br>
								README |    1 - <br>
								1 files changed, 0 insertions(+), 1 deletions(-) <br>
							</blockquote>
							
							Você irá notar a frase <strong>"Fast forward"</strong> no merge. Em razão do branch que você fez o merge <strong>apontar para o commit que está diretamente acima do commit que você se encontra</strong>, Git avança o ponteiro adiante. Em outras palavras, quando você tenta fazer o merge de um commit com outro que pode ser alcançado seguindo o histórico do primeiro, Git simplifica as coisas movendo o ponteiro adiante porque não existe modificações divergente para fazer o merge — isso é chamado de <strong>"fast forward"</strong>.  
							<br><br>

							Sua modificação está agora no snapshot do commit apontado pelo <strong>branch master</strong>, e você pode fazer o deploy, veja na figura abaixo:  
							<br>
							
							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0314-tn.png" alt="">
							<strong>Depois do merge seu branch master aponta para o mesmo local que o branch hotfix(Isso porque os commits da branche master e hotfix são adjacentes).</strong>  
							<br><br>

							Depois que a sua correção super importante foi enviada, você está pronto para voltar ao trabalho que estava fazendo antes de ser interrompido. No entanto, primeiro você <strong>apagará o branch hotfix</strong>, pois você não precisa mais dele — o branch master aponta para o mesmo local. Você pode excluí-lo com a opção <strong>-d</strong> em <strong>git branch</strong>:  
							<br>

							<blockquote>
								$ git branch -d hotfix <br>
								Deleted branch hotfix (3a0874c). <br> 
							</blockquote>

							Agora você pode voltar para o trabalho incompleto no branch da tafera <strong>#53</strong> e continuar a trabalhar nele:  
							<br>

							<blockquote>
								$ git checkout iss53 <br>
								Switched to branch "iss53" <br>
								$ vim index.html <br>
								$ git commit -a -m 'novo rodapé terminado [issue 53]' <br>
								[iss53]: created ad82d7a: "novo rodapé terminado [issue 53]" <br>
									1 files changed, 1 insertions(+), 0 deletions(-) <br>
							</blockquote>
							
							Veja a figura abaixo para entender melhor como serie esse fluxo de trabalho:  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0315-tn.png" alt="">  
							<strong>Seu branch iss53 pode avançar de forma independente.</strong>  
							<br><br>	
							
							Vale a pena lembrar aqui que o trabalho feito no seu branch <strong>hotfix</strong> não existe nos arquivos do seu branch <strong>iss53</strong>. Se você precisa incluí-lo, você pode fazer o merge do seu branch <strong>master</strong> no seu branch <strong>iss53</strong> executando o comando <strong>git merge master</strong>, ou você pode esperar para integrar essas mudanças até você decidir fazer o pull do branch <strong>iss53</strong> no <strong>master</strong> mais tarde.  
							<br><br>

							<strong>Merge Básico</strong>
							<br>

							Suponha que você decidiu que o trabalho na <strong>tarefa #53(branching)</strong> está completo e pronto para ser feito o merge no branch <strong></strong>. Para fazer isso, você fará o merge do seu branch <strong>iss53</strong>, bem como o merge do branch <strong>hotfix</strong> de antes. Tudo que você tem a fazer é executar o checkout do branch para onde deseja fazer o merge e então rodar o comando <strong>git merge</strong>:  
							<br>

							<blockquote>
								$ git checkout master <br>
								$ git merge iss53 <br>
								Merge made by recursive. <br>
									README | 1 + <br>
									1 files changed, 1 insertions(+), 0 deletions(-) <br>
							</blockquote>

							Isso parece um pouco diferente do merge de <strong>hotfix</strong> que você fez antes. Neste caso, o histórico do seu desenvolvimento divergiu em algum ponto anterior. Pelo fato do commit no branch em que você está não ser um ancestral direto do branch que você está fazendo o merge, Git tem um trabalho adicional. Neste caso, Git faz um merge simples de três vias, usando os dois snapshots apontados pelas pontas dos branches e o ancestral comum dos dois. A figura abaixo destaca os três snapshots que Git usa para fazer o merge nesse caso.  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0316-tn.png" alt=""> 
							<strong>Git identifica automaticamente a melhor base ancestral comum para o merge do branch.</strong>  
							<br><br>

							Em vez de simplesmente avançar o ponteiro do branch adiante, Git cria um novo snapshot que resulta do <strong>merge de três vias</strong> e automaticamente cria um <strong>novo commit</strong> que aponta para as vias. Isso é conhecido como um merge de commits e é especial pois tem mais de um pai.  
							<br><br>

							Veja na figura abaixo como isso funciona:  
							<br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0317-tn.png" alt="">
							<strong>Git cria automaticamente um novo objeto commit que contém as modificações do merge.</strong>  
							<br><br>

							Vale a pena destacar que o Git determina o melhor ancestral comum para usar como base para o merge; isso é diferente no CVS ou Subversion (antes da versão 1.5), onde o desenvolvedor que está fazendo o merge tem que descobrir a melhor base para o merge por si próprio. Isso faz o merge muito mais fácil no Git do que nesses outros sistemas.  
							<br><br>

							Agora que foi feito o merge no seu trabalho, você não precisa mais do branch <strong>iss53</strong>. Você pode apagá-lo e fechar manualmente o chamado no seu gerenciador de chamados:  
							<br>
							
							<blockquote>
								$ git branch -d iss53 <br>
							</blockquote>

							<strong>Conflitos de Merge Básico</strong>
							<br>

							Às vezes, esse processo não funciona sem problemas. Se você alterou a mesma parte do mesmo arquivo de forma diferente nos dois branches que está fazendo o merge, Git não será capaz de executar o merge de forma clara. Se sua correção para o erro <strong>#53</strong> alterou a mesma parte de um arquivo que <strong>hotfix</strong>, você terá um conflito de merge parecido com isso:  
							<br><br>
							
							<blockquote>
								$ git merge iss53 <br>
								Auto-merging index.html <br>
								CONFLICT (content): Merge conflict in index.html <br>
								Automatic merge failed; fix conflicts and then commit the result. <br>
							</blockquote>

							Git não criou automaticamente um novo commit para o merge. Ele fez uma pausa no processo enquanto você resolve o conflito. Se você quer ver em quais arquivos não foi feito o merge, em qualquer momento depois do conflito, você pode executar <strong>git status</strong>:  
							<br><br>
							
							<blockquote>
								[master*]$ git status <br>
								index.html: needs merge <br>
								# On branch master <br>
								# Changes not staged for commit: <br>
								#   (use "git add <file>..." to update what will be committed) <br>
								#   (use "git checkout -- <file>..." to discard changes in working directory) <br>
								#
								#    unmerged:   index.html 
							</blockquote>

							Qualquer coisa que tem conflito no merge e não foi resolvido é listado como "unmerged". Git adiciona marcadores padrão de resolução de conflitos nos arquivos que têm conflitos, para que você possa abri-los manualmente e resolver esses conflitos. Seu arquivo terá uma seção parecida com isso:  
							<br><br>

							<blockquote>
								<<<<<<< HEAD:index.html <br>
								<div id="footer">contato : email.support@github.com</div> <br>
								======= <br>
								<div id="footer"> <br>
									por favor nos contate em support@github.com <br>
								</div> <br>
								>>>>>>> iss53:index.html <br>  
							</blockquote>

							Isso significa que a versão em <strong>HEAD</strong> (seu branch master, pois era isso que você tinha quando executou o comando merge) é a parte superior desse bloco (tudo acima de =======), enquanto a versão no seu branch <strong>iss53</strong> é toda a parte inferior. Para resolver esse conflito, você tem que optar entre um lado ou outro, ou fazer o merge do conteúdo você mesmo. Por exemplo, você pode resolver esse conflito através da substituição do bloco inteiro por isso:  
							<br><br>

							<blockquote>
								<div id="footer"> <br>
									por favor nos contate em email.support@github.com <br>
								</div> <br>
							</blockquote>

							Esta solução tem um pouco de cada seção, e eu removi completamente as linhas <<<<<<<, =======, e >>>>>>>. Depois que você resolveu cada uma dessas seções em cada arquivo com conflito, rode git add em cada arquivo para marcá-lo como resolvido. Colocar o arquivo na área de seleção o marcar como resolvido no Git. Se você quer usar uma ferramenta gráfica para resolver esses problemas, você pode executar git mergetool, que abre uma ferramenta visual de merge adequada e percorre os conflitos:  
							<br><br>

							<blockquote>
								$ git mergetool
								merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff <br>
								Merging the files: index.html <br>
								
								Normal merge conflict for 'index.html': <br>
									{local}: modified <br>
									{remote}: modified <br>
								Hit return to start merge resolution tool (opendiff): <br>
							</blockquote>
						</div>
						<!-- /Fim da seção 3.1 - Merging -->


						<br><br>
						<!-- Início da seção 3.2 - Gerenciamento de Branch -->
						<div id="gerenciamento-de-branch">
							<h6>3.2 - Gerenciamento de Branch</h6>

							Agora que você criou, fez merge e apagou alguns branches, vamos ver algumas ferramentas de gerenciamento de branches que serão úteis quando você começar a usá-los o tempo todo.  
							<br><br>

							O comando <strong>git branch</strong> faz mais do que criar e apagar branches. Se você executá-lo sem argumentos, você verá uma lista simples dos seus branches atuais:  
							<br><br>
							
							<blockquote>
								$ git branch <br>
								iss53 <br>
								* master <br>
								testing  <br>
							</blockquote>

							Note o caractere <strong>*</strong> que vem antes do branch <strong>master</strong>: ele indica o branch que você está atualmente (fez o checkout). Isso significa que se você fizer um commit nesse momento, o branch <strong>master</strong> irá se mover adiante com seu novo trabalho. Para ver o último commit em cada branch, você pode executar o comando <strong>git branch -v</strong>:  
							<br><br>
							
							<blockquote>
								$ git branch -v <br>
								iss53   93b412c consertar problema em javascript <br>
								* master  7a98805 Merge branch 'iss53' <br>
								testing 782fd34 adicionar drigols para a lista de autores nos readmes <br>
							</blockquote>

							Outra opção útil para saber em que estado estão seus branches é filtrar na lista somente branches que você já fez ou não o merge no branch que você está atualmente. As opções <strong>--merged</strong> e <strong>--no-merged</strong> estão disponíveis no Git desde a versão 1.5.6 para esse propósito. Para ver quais branches já foram mesclados no branch que você está, você pode executar <strong>git branch --merged</strong>:  
							<br><br>

							<blockquote>
								$ git branch --merged <br>
								iss53 <br>
								* master <br>
							</blockquote>

							Por você já ter feito o merge do branch <strong>iss53</strong> antes, você o verá na sua lista. Os branches nesta lista sem o <strong>*</strong> na frente em geral podem ser apagados com <strong>git branch -d</strong>; você já incorporou o trabalho que existia neles em outro branch, sendo assim você não perderá nada.  
							<br><br>

							Para ver todos os branches que contém trabalho que você ainda não fez o merge, você pode executar </strong>git branch --no-merged</strong>:  
							<br><br>
							
							<blockquote>
								$ git branch --no-merged <br>
								testing <br>
							</blockquote>

							Isso mostra seu outro branch. Por ele conter trabalho que ainda não foi feito o merge, tentar apagá-lo com <strong>git branch -d</strong> irá falhar:  
							<br><br>

							<blockquote>
								$ git branch -d testing <br>
								error: The branch 'testing' is not an ancestor of your current HEAD. <br>
								If you are sure you want to delete it, run `git branch -D testing`. <br>
							</blockquote>

							  Se você quer realmente apagar o branch e perder o trabalho que existe nele, você pode forçar com </strong>-D</strong>, como a útil mensagem aponta.  
						</div>
						<!-- /Fim da seção 3.2 - Gerenciamento de Branch -->


						<br><br>
						<!-- Início da seção 3.3 - Fluxo de trabalho com branch -->
						<div id="workflows">
							<h6>3.3 - Fluxo de trabalho com branch</h6>
								
							Devido ao Git usar um merge de três vias, fazer o merge de um branch em outro várias vezes em um período longo é geralmente fácil de fazer. Isto significa que você pode ter vários branches que ficam sempre abertos e que são usados em diferentes estágios do seu ciclo de desenvolvimento; você pode regularmente fazer o merge de alguns deles em outros.  
							<br><br>

							Muitos desenvolvedores Git tem um fluxo de trabalho que adotam essa abordagem, como ter somente código completamente estável em seus branches <strong>master</strong> — possivelmente somente código que já foi ou será liberado. Eles têm outro branch paralelo chamado <strong>develop</strong> ou algo parecido em que eles trabalham ou usam para testar estabilidade — ele não é necessariamente sempre estável, mas quando ele chega a tal estágio, pode ser feito o merge com o branch master. Ele é usado para puxar (pull) branches tópicos <strong>(topic, branches de curta duração, como o seu branch iss53 anteriormente)</strong> quando eles estão prontos, para ter certeza que eles passam em todos os testes e não acrescentam erros.  
							<br><br>

							Na realidade, nós estamos falando de <strong>ponteiros avançando na linha de commits</strong> que você está fazendo. Os branches estáveis estão muito atrás na linha histórica de commits, e os branches de ponta (que estão sendo trabalhados) estão a frente no histórico, veja a figura abaixo:  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0318-tn.png" alt="">  
							<strong>Branches mais estáveis geralmente ficam atrás no histórico de commits.</strong>  
							<br><br>

							Normalmente é mais fácil pensar neles como um contêiner de trabalho, onde conjuntos de commits são promovidos a um contêiner mais estável quando eles são completamente testados, veja a ilustração abaixo:  
							<br><br>
							
							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/book/en/v2/images/lr-branches-2.png" alt="">
							<br><br>
								
							A ideia é que seus branches estejam em vários níveis de estabilidade; quando eles atingem um nível mais estável, é feito o merge no branch acima deles. Repetindo, ter muitos branches de longa duração não é necessário, mas geralmente é útil, especialmente quando você está lidando com projetos muito grandes ou complexos.  
							<br><br>
							
							<strong id="topic">Branches Tópicos (topic)</strong>
							<br>

							Branches tópicos, entretanto, são úteis em projetos de qualquer tamanho. Um branch tópico é um branch de curta duração que você cria e usa para uma funcionalidade ou trabalho relacionado. Isso é algo que você provavelmente nunca fez com um controle de versão antes porque é geralmente muito custoso criar e fazer merge de branches. Mas no Git é comum criar, trabalhar, mesclar e apagar branches muitas vezes ao dia.  
							<br><br>

							Você viu isso na seção anterior com os branches <strong>iss53</strong> e <strong>hotfix</strong> que você criou. Você fez commits neles e os apagou depois que fez o merge com seu branch principal. Tecnicamente, isso lhe permite mudar completamente e rapidamente o contexto — em razão de seu trabalho estar separado em contêineres onde todas as modificações naquele branch estarem relacionadas ao tópico, é fácil ver o que aconteceu durante a revisão de código. Você pode manter as mudanças lá por minutos, dias, ou meses, e mesclá-las quando estivem prontas, não importando a ordem que foram criadas ou trabalhadas.  
							<br><br>

							<strong>Exemplo:</strong>  
							<br><br>

							Considere um exemplo onde:  
							
							<ul>
								<li>1. Você está fazendo um trabalho (no <strong>master</strong>);</li>
								<li>2. Cria um branch para um erro <strong>(iss91)</strong>, trabalha nele um pouco;</li>
								<li>3. Cria um segundo branch para testar uma nova maneira de resolver o mesmo problema <strong>(iss91v2)</strong>;</li>
								<li>4. Volta ao seu branch principal(<strong>master</strong>) e trabalha nele por um tempo;</li>
								<li>5. Cria um novo branch para trabalhar em algo que você não tem certeza se é uma boa ideia <strong>(dumbidea)</strong>.</li>
							</ul>
							<br>

							Seu histórico de commits irá se parecer com a figura abaixo:  
							<br><br>
							
							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0320-tn.png" alt="">
							<strong>Seu histórico de commits com multiplos branches tópicos.</strong>  
							<br><br>

							Agora, vamos dizer que você decidiu que sua segunda solução é a melhor para resolver o erro <strong></strong>; e você mostrou seu branch <strong>dumbidea</strong> para seus colegas de trabalho, e ele é genial. Agora você pode jogar fora o branch original <strong>iss91</strong> (perdendo os commits <strong>C5</strong> e <strong>C6</strong>) e fazer o <strong>merge</strong> dos dois restantes. Seu histórico irá se parecer com a figura abaixo:  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0321-tn.png" alt="">  
							<strong>Seu histórico depois de fazer o merge de dumbidea e iss91v2.</strong>  
							<br><br>

							É importante lembrar que você esta fazendo tudo isso com seus branches localmente. Quando você cria e faz o merge de branches, tudo está sendo feito somente no seu repositório Git — nenhuma comunicação com o servidor esta sendo feita.  
						</div>
						<!-- /Fim da seção 3.3 - Fluxo de trabalho com branch  -->


						<br><br>
						<!-- Início da seção 3.4 - Branch remotas + git fetch -->
						<div id="branch-remotas">
							<h6>3.4 - Branch remotas + git fetch</h6>
							<br>

							Branches remotos são <strong>referências ao estado</strong> de seus branches no seu <strong>repositório remoto</strong>. São branches locais que você não pode mover, <strong>eles se movem automaticamente sempre que você faz alguma comunicação via rede</strong>. Branches remotos agem como marcadores para lembrá-lo onde estavam seus branches no seu repositório remoto na última vez que você se conectou a eles.  
							<br><br>

							Eles seguem o padrão <strong>(remote)/(branch)</strong>. Por exemplo, se você quer ver como o branch <strong>master</strong> estava no seu repositório remoto <strong>origin</strong> na última vez que você se comunicou com ele, você deve ver o branch <strong>origin/master</strong>.  
							<br><br>

							Se você estivesse trabalhando em um problema com alguns colegas e eles colocassem o branch <strong>iss53</strong> no repositório, você poderia ter seu próprio branch <strong>iss53</strong>; mas o branch no servidor iria fazer referência ao commit em <strong>origin/iss53</strong>.  
							<br><br>

							Isso pode parecer um pouco confuso, então vamos ver um exemplo. Digamos que você tem um servidor Git na sua rede em <strong>git.ourcompany.com</strong>:  
							
							<ul>
								<li>1. Se você cloná-lo, Git automaticamente dá o nome origin para ele;</li>
								<li>2. Baixa todo o seu conteúdo;</li>
								<li>3. Cria uma referência para onde o branch <strong>master</strong> dele está, e dá o nome <strong>origin/master</strong> para ele localmente, e você não pode movê-lo.</li>
							</ul>

							O Git também dá seu próprio branch <strong>master</strong> como ponto de partida no mesmo local onde o branch <strong>master</strong> remoto está, a partir de onde você pode trabalhar, veja figura abaixo:  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0322-tn.png" alt=""> 
							<strong>Um comando clone do Git dá a você seu próprio branch master e origin/master faz referência ao branch master original.</strong>  
							<br><br>

							Se você estiver trabalhando no seu branch master local, e, ao mesmo tempo, alguém envia algo para <strong>git.ourcompany.com</strong> atualizando o branch master, seu histórico avançará de forma diferente. <strong>Além disso, enquanto você não fizer contado com seu servidor original, seu origin/master não se moverá</strong>, veja a figura abaixo:  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0323-tn.png" alt="">
							<strong>Veja que a branch master avançou no servidor(alguém enviou algo para servidor remoto), e sua branch origin/master continua de onde você clonou. Isso, porque você não fez contato com o servidor ainda.</strong>  
							<br><br>
							
							<strong>git fetch origin</strong>
							<br><br>

							Para sincronizar suas coisas, você executa o comando <strong>git fetch origin</strong>. Esse comando:  
							
							<ul>
								<li>Verifica qual servidor "origin" representa (nesse caso, é git.ourcompany.com);</li>
								<li>Obtém todos os dados que você ainda não tem;</li>
								<li>Atualiza o seu banco de dados local, movendo o seu origin/master para a posição mais recente e atualizada.</li>
							</ul>

							Veja a figura abaixo:
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0324-tn.png" alt="">
							<strong>O comando git fetch atualiza suas referências remotas.</strong>  
							<br><br>
							
							<strong>Múltiplos Servidores</strong>
							<br><br>
								
							Para demostrar o uso de múltiplos servidores remotos e como os branches remotos desses projetos remotos parecem, vamos assumir que você tem outro servidor Git interno que é usado somente para desenvolvimento por um de seus times. Este servidor está em:  
							<br><br>

							<blockquote>
								git.team1.ourcompany.com
							</blockquote>

							Você pode adicioná-lo como uma nova referência remota ao projeto que você está atualmente trabalhando executando o comando <strong>git remote add</strong>.  
							<br><br>

							Dê o nome de <strong>teamone</strong>, que será o apelido para aquela URL, veja a figura abaixo:  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0325-tn.png" alt="">
							<strong>Adicionando um novo servidor.</strong>  
							<br><br>

							Agora, você pode executar o comando <strong>git fetch teamone</strong> para obter tudo que o servidor <strong>teamone</strong> tem e você ainda não, veja a figura abaixo:  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0326-tn.png" alt="">
							 <br><br>  
								
							Por esse servidor ter um subconjunto dos dados que seu servidor <strong>origin</strong> tem, Git não obtém nenhum dado, somente cria um branch chamado <strong>teamone/master</strong> que faz referência ao commit que teamone tem no master dele.
						</div>
						<!-- /Fim da seção 3.4 - Branch remotas + git fetch -->


						<br><br>
						<!-- Início da seção 3.5 - Rebasing -->
						<div id="rebasing">
							<h6>3.5 - Rebasing</h6>

							No Git, existem duas maneiras principais de integrar mudanças de um branch em outro: o <strong>merge</strong> e o <strong>rebase</strong>. Nessa seção você aprenderá o que é rebase, como fazê-lo, por que é uma ferramenta sensacional, e em quais casos você não deve usá-la.  
							<br><br>

							<strong>O Rebase Básico</strong>
							<br>

							Se você olhar para o exemplo abaixo(figura), você pode ver que você criou uma divergência no seu trabalho e fez commits em dois branches diferentes.  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0327-tn.png" alt="">
							<br><br>  
								
							A maneira mais fácil de integrar os branches, como já falamos, é o comando <strong>merge</strong>. Ele executa um merge de <strong>três vias</strong> entre os dois últimos snapshots (cópias em um determinado ponto no tempo) dos branches </strong>(C3 e C4)</strong> e o mais recente ancestral comum aos dois <strong>(C2)</strong>, criando um novo snapshot (e um commit), como é mostrado na figura abaixo:  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0328-tn.png" alt="">
							<br><br>  
								
							Porém, existe outro modo: você pode pegar o trecho da mudança que foi introduzido em <strong>C3</strong> e reaplicá-lo em cima do <strong>C4</strong>. No Git, isso é chamado de <strong>rebasing</strong>. Com o comando rebase, você pode pegar todas as mudanças que foram commitadas em um branch e replicá-las em outro.  
							<br><br>

							Nesse exemplo, se você executar o seguinte:
							<br>
							
							<blockquote>
								$ git checkout experiment <br>
								$ git rebase master <br>
								First, rewinding head to replay your work on top of it... <br>
								Applying: added staged command <br>
							</blockquote>

							Ele vai ao ancestral comum dos dois branches (no que você está e no qual será feito o rebase), pega a diferença (diff) de cada commit do branch que você está, salva elas em um arquivo temporário, restaura o branch atual para o mesmo commit do branch que está sendo feito o rebase e, finalmente, aplica uma mudança de cada vez. A figura abaixo ilustra esse processo:  
							<br><br>
							
							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0329-tn.png" alt=""> 
							<strong>Fazendo o rebase em C4 de mudanças feitas em C3.</strong>  
							<br><br>

							Nesse ponto, você pode ir ao branch master e fazer um merge fast-forward, como na figura abaixo:  
							<br><br>

							<img class="img-fluid mx-auto d-block" src="https://git-scm.com/figures/18333fig0330-tn.png" alt="">
							<br><br>
							
							Agora, o snapshot apontado por <strong>C3'</strong> é exatamente o mesmo apontado por <strong>C5</strong> no exemplo do merge. Não há diferença no produto final dessas integrações, mas o rebase monta um histórico mais limpo. Se você examinar um log de um branch com rebase, ele parece um histórico linear: como se todo o trabalho tivesse sido feito em série, mesmo que originalmente tenha sido feito em paralelo.  
							<br><br>

							Constantemente você fará isso para garantir que seus commits sejam feitos de forma limpa em um branch remoto — talvez em um projeto em que você está tentando contribuir mas não mantém. Nesse caso, você faz seu trabalho em um branch e então faz o rebase em <strong>origin/master</strong> quando está pronto pra enviar suas correções para o projeto principal. Desta maneira, o mantenedor não precisa fazer nenhum trabalho de integração — somente um merge ou uma inserção limpa.  
							<br><br>
							
							<strong>Os Perigos do Rebase</strong>
							<br>

							Apesar dos benefícios do rebase existem os inconvenientes, que podem ser resumidos em um linha:  
							<br><br>
							
							<blockquote>
								<strong>Não faça rebase de commits que você enviou para um repositório público.</strong>
							</blockquote>

							Se você seguir essa regra você ficará bem. Se não seguir, as pessoas te odiarão e você será desprezado por amigos e familiares.  
							<br><br>

							Quando você faz o rebase, você está abandonando commits existentes e criando novos que são similares, mas diferentes. Se fizer o push de commits em algum lugar e outros pegarem e fizerem trabalhos baseado neles e você reescrever esses commits com <strong>git rebase</strong> e fizer o push novamente, seus colaboradores terão que fazer o merge de seus trabalhos novamente e as coisas ficarão bagunçadas quando você tentar trazer o trabalho deles de volta para o seu.
						</div>
						<!-- /Fim da seção 3.5 - Rebasing -->

						<br><br>
						<!-- Início da seção de Referências -->
						<div id="reference">
							<h6>Referências:</h6>
							https://git-scm.com/book/pt-br/v1/ <br>
							https://git-scm.com/book/en/v2/ <br>				
						</div>
						<!-- /Fim da seção de Referências  -->
						<br><br>
                    </div>
                    <!-- início do col-md-12 -->
                </div>
                <!-- /Fim da linha(.row) conteúdo do artigo -->
            </div>
            <!-- /Fim do container de artigos -->


            <!-- Início do footer da página -->
            <footer id="id-footer">
                <!-- Início do .container -->
                <div class="container">
                    <!-- Início da linha(.row) do footer -->
                    <div class="row">

                        <!-- Início do Grid de localização -->
                        <div class="footer-col col-md-4">
                            <h3>Location</h3>
                            <hr class="style-four">
                            <!-- Início da tag de endereço(address) -->
                            <address>
                                <strong>drigols - Software Engineer</strong><br>
                                Campina Grande - PB, CEP:58401624<br>
                                Dr. Vasconcelos, Nº 860, Alto Branco<br>
                                <abbr title="Phone">TIM</abbr> - (83) 9 96500112<br>
                                <abbr title="Phone">OI</abbr>  - (83) 9 88126010
                            </address>
                            <!-- /Fim da tag de endereço(address) -->
                            <!-- Início da tag de endereço(address) -->
                            <address>
                                <strong>Rodrigo Leite da Silva</strong><br>
                                <a href="mailto:#">drigols.creative@gmail.com</a>
                            </address>
                            <!-- /Fim da tag de endereço(address) -->
                        </div>
                        <!-- /Fim do Grid de localização -->

                        <!-- Início do Grid de redes sociais -->
                        <div class="footer-col col-md-8">
                            <h3 class="text-center">Around the Web</h3>
                            <hr class="style-four">
                            <!-- Início da lista com as redes sociais -->
                            <ul class="list-inline">
   
                                <!-- GitHub-->
                                <li class="list-inline-item">
                                    <a href="https://github.com/drigols/" class="btn-social btn-outline" target="_blank" title="GitHub"><span class="sr-only">GitHub</span><i class="fa fa-fw fa-github"></i></a>
                                </li>
    
                                <!-- GitLab-->
                                <li class="list-inline-item">
                                    <a href="https://gitlab.com/drigols" class="btn-social btn-outline" target="_blank" title="GitLab"><span class="sr-only">GitLab</span><i class="fa fa-fw fa-gitlab"></i></a>
                                </li>
    
                                <!-- StackOverflow -->
                                <li class="list-inline-item">
                                        <a href="https://stackoverflow.com/users/8047904/drigols" class="btn-social btn-outline" target="_blank" title="StackOverflow"><span class="sr-only">StackOverflow</span><i class="fa fa-fw fa-stack-overflow"></i></a>
                                </li>
    
                                <!-- Trello -->
                                <li class="list-inline-item">
                                    <a href="https://trello.com/drigols" class="btn-social btn-outline" target="_blank" title="Trello"><span class="sr-only">Trello</span><i class="fa fa-fw fa-trello"></i></a>
                                </li>
    
                                <!-- Dribbble -->
                                <li class="list-inline-item">
                                    <a href="https://dribbble.com/drigols" class="btn-social btn-outline" target="_blank" title="Dribbble"><span class="sr-only">Dribbble</span><i class="fa fa-fw fa-dribbble"></i></a>
                                </li>
    
                                <!-- Linkedin -->
                                <li class="list-inline-item">
                                    <a href="https://www.linkedin.com/in/drigols/" class="btn-social btn-outline" target="_blank" title="Linkedin"><span class="sr-only">Linkedin</span><i class="fa fa-fw fa-linkedin"></i></a>
                                </li>
    
                                <!-- Twitter -->
                                <li class="list-inline-item">
                                    <a href="https://twitter.com/drigols_code" class="btn-social btn-outline" target="_blank" title="Twitter"><span class="sr-only">Twitter</span><i class="fa fa-fw fa-twitter"></i></a>
                                </li>
    
                                <!-- Google+ -->
                                <li class="list-inline-item">
                                        <a href="https://plus.google.com/114771423497801867159" class="btn-social btn-outline" target="_blank" title="Google+"><span class="sr-only">Google+</span><i class="fa fa-fw fa-google-plus"></i></a>
                                </li>
    
                                <!-- YouTube-->
                                <li class="list-inline-item">
                                        <a href="https://www.youtube.com/channel/UCE7F50ONDhetsROsLaMTwrQ" class="btn-social btn-outline" target="_blank" title="YouTube"><span class="sr-only">YouTube</span><i class="fa fa-fw fa-youtube"></i></a>
                                </li>
    
                                <!-- Instagram -->
                                <li class="list-inline-item">
                                        <a href="https://www.instagram.com/drigols/" class="btn-social btn-outline" target="_blank" title="Instagram"><span class="sr-only">Instagram</span><i class="fa fa-fw fa-instagram"></i></a>
                                </li>
    
                                <!-- Facebook Page -->
                                <li class="list-inline-item">
                                    <a href="https://www.facebook.com/DrigolsCreative/" class="btn-social btn-outline" target="_blank" title="Facebook"><span class="sr-only">Facebook</span><i class="fa fa-fw fa-facebook"></i></a>
                                </li>
    
                            </ul>
                            <!-- /Fim da lista com as redes sociais -->
                        </div>
                        <!-- /Fim do Grid de redes sociais -->
                    </div>
                    <!-- /Fim da linha(.row) do footer -->
                </div>
                <!-- /Fim do .container -->
            </footer>
            <!-- /Fim do footer da página-->

        </div>
        <!-- /Fim da section de artigos -->


        <!-- Optional JavaScript -->
        <!-- jQuery first, then Popper.js, then Bootstrap JS -->
        <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
            crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.11.0/umd/popper.min.js" integrity="sha384-b/U6ypiBEHpOf/4+1nzFpr53nxSS+GLCkfwBdFNTxtclqqenISfwAzpKaMNFNmj4"
            crossorigin="anonymous"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/js/bootstrap.min.js" integrity="sha384-h0AbiXch4ZDo7tp9hKZ4TsHbi047NrKGLO3SEJAg45jXxnGIfYzk4Si90RDIqNm1"
            crossorigin="anonymous"></script>
    </body>
    <!-- /Fim do corpo(body) HTML5 -->
</html>
<!-- /Fim do documento HTML5 -->
